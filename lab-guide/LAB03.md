# LAB 03 - Serverless with AWS Chalice
This exercise is divided into two parts. The first part is about the AWS serverless framework Chalice, and the second part is using the Chalice to run the CloudAlbum application.

## Serverless framework
There are various serverless frameworks. Here is a brief introduction to each of the serverless frameworks.

### AWS Chalice
`Chalice` is a microframework(https://github.com/aws/chalice) for writing serverless apps in python. It makes it simple for you to use AWS Lambda and Amazon API Gateway to build serverless apps. It allows you to quickly create and deploy applications that use AWS Lambda. It provides:

* A command line tool for creating, deploying, and managing your app
* A decorator based API for integrating with Amazon API Gateway, Amazon S3, Amazon SNS, Amazon SQS, and other AWS services.
* Automatic IAM policy generation

### Serverless 
The `Serverless` Framework (https://serverless.com) is an MIT open source framework that’s actively developed and maintained by a full-time team. At its essence, it allows users to define a serverless application—including Lambda functions and API Gateway APIs—and then deploy it using a command-line interface (CLI). It helps you organize and structure serverless applications, which is of great benefit as you begin to build larger systems, and it’s fully extensible via its plugin system.

### Zappa
`Zappa` (https://github.com/Miserlou/Zappa) makes it super easy to build and deploy server-less, event-driven Python applications (including, but not limited to, WSGI web apps) on AWS Lambda + API Gateway. Think of it as "serverless" web hosting for your Python apps. That means infinite scaling, zero downtime, zero maintenance - and at a fraction of the cost of your current deployments!

**NOTE:** These `serverless frameworks` have many similarities. You can choose one framework from the above. In this hands-on lab, **you will use AWS Chalice**.

## TASK 1 : Build a simple AWS Chalice serverless app.
This TASK will provide an introduction on how to use AWS Chalice and provide instructions on how to go about building your very first Chalice application. 

1. To start using Chalice, you will need to install Chalice python package.

```
sudo pip-3.6 install chalice
```

2. To check that chalice was installed, run:
```
chalice --version
chalice 1.3.0
```

3. Now AWS Chalice serverless framework installed, it is time to create your first Chalice application. Run the `chalice new-project` command to create a project called `myapp`:

```
mkdir -p ~/environment/aws-chalice-migration-workshop/LAB03/01-Chalice/
cd ~/environment/aws-chalice-migration-workshop/LAB03/01-Chalice/
chalice new-project myapp
```

4. Review the generated files which generated by Chalice framework.
```
sudo yum install tree
tree -a .
<username>:~/environment/aws-chalice-migration-workshop/LAB03/01-Chalice (master) $ tree -a .
.
└── myapp
    ├── app.py
    ├── .chalice
    │   └── config.json
    ├── .gitignore
    └── requirements.txt

```
* You can find above files after run `chalice new-project myapp` command. 

```
cd myapp
vi app.py (or use open int the Cloud9 default editor)
```
```python
from chalice import Chalice

app = Chalice(app_name='myapp')


@app.route('/')
def index():
    return {'hello': 'world'}

```
* It looks very similar to the **Flask** framework. 

5. Run Chalice application as a local application in your machine.
```
chalice local --port 8080
```
You can see the following message: `Serving on 127.0.0.1:8080`
if you want detailed execution information, you can run Chalice as debug mode `chalice --debug local`

For the convenience of test, we will use `httpie` in the shell.

```
sudo yum install httpie
```

* After `httpie` is installed, you can run following command for the application test.
```
http localhost:8080/
HTTP/1.1 200 OK
Content-Length: 18
Content-Type: application/json
Date: Sun, 05 Aug 2018 07:02:01 GMT
Server: BaseHTTP/0.6 Python/3.6.5

{
    "hello": "world"
}

```

6. To help your understanding, consider the following example.
```python
from chalice import Chalice
from chalice import Response 
import logging

app = Chalice(app_name='myapp')
app.debug = True
app.log.setLevel(logging.DEBUG)


@app.route('/')
def index():
    return {'hello': 'world'}


@app.route('/users/{name}', methods=['GET'])
def user_info(name):
    request=app.current_request
    app.log.debug(request.method)
    app.log.debug(request.to_dict())
    body='<h1> Your name is {0}.</h1>'.format(name)

    return Response(body=body,
        status_code=200,
        headers={'Content-Type': 'text/html; charset=utf-8'})


@app.route('/users', methods=['POST'])
def user_add():
    request = app.current_request
    app.log.debug(request.method)
    app.log.debug(request.to_dict())

    return Response(body=request.json_body,
        status_code=200,
        headers={'Content-Type': 'application/json; charset=utf-8'})
```

* Review above code for new `app.py`. `Response` and `logging` are importted from top of the `app.py` file. Debug option is enabled for the application logging. `user_info` and `user_add` functions are added.

* Replace `app.py` file with the contents of above source code.

7. Run the new version of `myapp`.
```
chalice local --port 8080
```

8. Test new Chalice application. For the convenience, you can open additional terminal in the Cloud9 environment. 
![Open new terminal](images/lab03-task1-new-terminal.png)

* Test #1: `@app.route('/users/{name}', methods=['GET'])`
```
$ http localhost:8080/users/David
HTTP/1.1 200 OK
Content-Length: 29
Content-Type: text/html; charset=utf-8
Date: Sun, 05 Aug 2018 08:19:38 GMT
Server: BaseHTTP/0.6 Python/3.6.5

<h1> Your name is David.</h1>

```
* Debug log for this request:

```
myapp - DEBUG - GET
myapp - DEBUG - {'query_params': None, 'headers': {'host': 'localhost:8080', 'user-agent': 'HTTPie/0.9.9', 'accept-encoding': 'gzip, deflate', 'accept': '*/*', 'connection': 'keep-alive'}, 'uri_params': {'name': 'David'}, 'method': 'GET', 'context': {'httpMethod': 'GET', 'resourcePath': '/users/{name}', 'identity': {'sourceIp': '127.0.0.1'}, 'path': '/users/David'}, 'stage_vars': {}}
127.0.0.1 - - [05/Aug/2018 08:19:38] "GET /users/David HTTP/1.1" 200 -

```

* Test #2: `@app.route('/users', methods=['POST'])`
```
$ echo '{"name": "David", "age": 22, "job": "student"}' | http localhost:8080/users
HTTP/1.1 200 OK
Content-Length: 46
Content-Type: application/json; charset=utf-8
Date: Sun, 05 Aug 2018 08:26:13 GMT
Server: BaseHTTP/0.6 Python/3.6.5

{
    "age": 22,
    "job": "student",
    "name": "David"
}


```
* Debug log for this request:
```
myapp - DEBUG - POST
myapp - DEBUG - {'query_params': None, 'headers': {'host': 'localhost:8080', 'user-agent': 'HTTPie/0.9.9', 'accept-encoding': 'gzip, deflate', 'accept': 'application/json, */*', 'connection': 'keep-alive', 'content-type': 'application/json', 'content-length': '48'}, 'uri_params': {}, 'method': 'POST', 'context': {'httpMethod': 'POST', 'resourcePath': '/users', 'identity': {'sourceIp': '127.0.0.1'}, 'path': '/users'}, 'stage_vars': {}}
127.0.0.1 - - [05/Aug/2018 08:26:13] "POST /users HTTP/1.1" 200 -

```

10. Deploy to API Gateway and Lambda. You can deploy this application using Chalice CLI command.
```
chalice deploy
```
* However, you will be failed with following messages.

```
Creating deployment package.
Updating policy for IAM role: myapp-dev
Traceback (most recent call last):

  (......)

botocore.exceptions.ClientError: An error occurred (InvalidClientTokenId) when calling the PutRolePolicy operation: The security token included in the request is invalid

During handling of the above exception, another exception occurred:

Traceback (most recent call last):

  (......)

chalice.deploy.deployer.ChaliceDeploymentError: ERROR - While deploying your chalice application, received the following error:

 An error occurred (InvalidClientTokenId) when calling the PutRolePolicy 
 operation: The security token included in the request is invalid

```

* The default Cloud9 working environment configure temporary 'shared-credentials-file' type crendentials. Details are in the Cloud9 document. (https://docs.aws.amazon.com/ko_kr/cloud9/latest/user-guide/credentials.html#credentials-temporary)

* For the convenience deploy, configure your credential environment variables with enough permissions rights. (such as admin access right credential)
```
export AWS_ACCESS_KEY_ID=
export AWS_SECRET_ACCESS_KEY=
```

* Run `chalice deploy` again.
```
chalice deploy
Creating deployment package.
Updating policy for IAM role: myapp-dev
Creating lambda function: myapp-dev
Creating Rest API
Resources deployed:
  - Lambda ARN: arn:aws:lambda:ap-southeast-1:1234567890:function:myapp-dev
  - Rest API URL: https://aavvueq9we.execute-api.ap-southeast-1.amazonaws.com/api/
```  
* You can get api URL easily using below command.
```
chalice url
https://aavvueq9we.execute-api.ap-southeast-1.amazonaws.com/api/
```

* Test your first Chalice application. You can refer to `step 8`.

* You can check the files of `deplyed` and `deployments` directories.
```
<username>:~/environment/aws-chalice-migration-workshop/LAB03/01-Chalice (master) $ tree -a .
.
└── myapp
    ├── app.py
    ├── .chalice
    │   ├── config.json
    │   ├── deployed
    │   │   └── dev.json
    │   └── deployments
    │       └── d41d8cd98f00b204e9800998ecf8427e-python3.6.zip
    ├── .gitignore
    ├── __pycache__
    │   └── app.cpython-36.pyc
    └── requirements.txt
5 directories, 7 files
```

11. Examine your **API Gateway** and **Lambda** Console. You can see the new API and Lambda functions.
* API Gateway console (myapp)
![API gateway console](images/lab03-task1-api-gw-console.png)

* Lambda console (myapp-dev)
![Lambda console](images/lab03-task1-lambda-console.png)


12. Delete deployed application
```
<username>:~/environment/aws-chalice-migration-workshop/LAB03/01-Chalice/myapp (master) $ chalice delete
Deleting Rest API: w2t3ueq9we
Deleting function: arn:aws:lambda:ap-southeast-1:1234567890:function:myapp-dev
Deleting IAM role: myapp-dev
```

* If it works well, let's go to next TASK!

## TASK 2 : CloudAlbum with AWS Chalice
We have removed server based components via LAB02. We are now going serverless by removing Web Server Tier and App Server Tier.

![Serverless application](images/lab03-task2-serverless.png)

Finally, all servers are gone!

![Serverless application](images/lab03-task2-serverless-full.png)


13. Let's take a look around `LAB03/02-CloudAlbum-Chalice/` directory.

```
$ cd ~/environment/aws-chalice-migration-workshop/LAB03/02-CloudAlbum-Chalice/cloudalbum/

$ tree -L 2 -a .
├── app.py
├── .chalice
│   └── config.json
├── chalicelib
│   ├── config.py
│   ├── __init__.py
│   ├── models_ddb.py
│   ├── templates
│   └── util.py
├── .gitignore
├── requirements.txt
└── vendor
    ├── bin
    ├── jinja2
    ├── Jinja2-2.10.dist-info
    ├── markupsafe
    ├── pyasn1
    ├── pyasn1-0.4.3.dist-info
    ├── python_jose-3.0.0.dist-info
    ├── rsa
    └── rsa-3.4.2.dist-info

```

* All of route functions are in the `app.py` and `template` and modules are in the `chalicelib` directory.

**3rd Party Packages:** 
There are two options for handling python package dependencies:

* `requirements.txt` - During the packaging process, Chalice will install any packages it finds or can build compatible wheels for. Specifically all pure python packages as well as all packages that upload wheel files for the `manylinux1_x86_64` platform will be automatically installable.

* `vendor/` - The contents of this directory are automatically added to the top level of the deployment package. Chalice will also check for an optional `vendor/` directory in the project root directory. The contents of this directory are automatically included in the top level of the deployment.

* Chalice will also check for an optional `vendor/` directory in the project root directory. The contents of this directory are automatically included in the top level of the deployment package (see Examples for specific examples). The `vendor/` directory is helpful in these scenarios:

* You need to include custom packages or binary content that is not accessible via pip. These may be internal packages that aren’t public.

* `Wheel files` are not available for a package you need from pip.

* A package is installable with requirements.txt but has optional c extensions. Chalice can build the dependency without the c extensions, but if you want better performance you can vendor a version that is compiled.

* As a general rule of thumb, code that you write goes in either `app.py` or `chalicelib/`, and dependencies are
either specified in `requirements.txt` or placed in the `vendor/` directory.

14. 
